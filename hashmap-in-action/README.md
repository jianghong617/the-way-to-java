# `HashMap-in-action`
> 学习 `HashMap` 的心得

## 1.解决哈希碰撞

- 重哈希
- 开放地址法
- 公共溢出区
- 链地址法



## 2.确实产生了哈希碰撞

```
如果: 确实产生了 Hash 碰撞                                                                   
1.扩容                                                                                
1.1.什么时候扩容?                                                                         
---- 先添加元素                                                                          
---- 判断是否达到阈值                                                                       
1.2.怎么扩容?                                                                           
---- 添加元素使用尾插法                                                                     
---- 如果对应角标位是单向链表,将单向链表进行数据迁移
---- 如果对应角标位是红黑树,将双向链表进行数据迁移    
---- -- 如果发现迁移完数据后,双向链表的结构小于/等于6,会将红黑树重新转回单向链表的结构        
---- 扩容后,数据迁移时,数据要么在原来位置,要么在原来位置+扩容长度
1.3.扩容后有什么问题(多线程环境)?                                                             
---- 多线程环境下会有数据丢失的问题
2.数据结构                                                                              
2.1.会形成单向链表                                                                         
---- 如果单向链表的长度大于|等于8,会转成红黑树+双向链表(扩容时使用)      
```



## 3.容量必须是2的幂次方数

```
为什么容量必须是2的幂次方数呢?                                                                                           
1.以2的幂次方数有一个特点,高位为1,后续全部为0,这样的数减一,就会变成刚才为1的位置为0,后续所有值都为1,这样减一之后的数,和任何数进行与运算,得到的结果,永远是0-2的幂次方减一,正好符合数组角标的范围 
-- 数学取模运算 10 % 16 == 10 & 15                                                                               
2.同时减一后,一定是一个奇数,末位一定是1,那么和其他数进行与运算后,得到的结果可能是奇数,也可能是偶数,那么可以充分利用数组的容量

3.2的幂次方数减一后,低位都是1,这样数组的索引位都有可能存入元素,如果低位不都是1,就会导致有些数组的索引位永远空缺,不利于数组的充分利用  

4.扩容时,便于重新定位元素的索引位,扩容的原则是原来数组的2倍,那么扩容后,数组容量还是一个2的幂次方数,原数组中的元素在新数组中,要么在原始索引位,要么在原始索引位+扩容值的位置,避免了重新hash的效率问题 
```



## 4.`put` 流程

### 4.1.`HashMap`

> 大致流程

![](.\doc\hashmap.jpg)

> Resize()

![](.\doc\resize.jpg)

### 4.2.`ConcurrentHashMap`

> 大致流程
>
> ...