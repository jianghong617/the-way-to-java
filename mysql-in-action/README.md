# `MySQL`

## 1.实战示例

[student.sql](./doc/student.sql)



### 1.1.实现虚拟列分组递增

```sql
SELECT
	t1.id,
	( @rowNo := CASE WHEN @studentCode = t1.`student_code` THEN @rowNo + 0 ELSE @rowNo + 1 END ) AS studentNo,
	( @studentCode := t1.`student_code` ) AS studentCode,
	t1.`student_name` AS studentName 
FROM
	`student` t1,
	( SELECT @rowNo := 0, @studentCode := '' ) t2 
ORDER BY
	t1.`student_code`;
```



### 1.2.查询重复的数据

> 排除 ` id` 最小的一条

#### 1.2.1.方案一

```sql
SELECT
	*
FROM
	student s 
WHERE
	s.student_code IN ( SELECT student_code FROM `student` t1 GROUP BY t1.student_code HAVING COUNT( * ) > 1 ) 
	AND s.id NOT IN ( SELECT MIN( id ) FROM `student` t2 GROUP BY t2.student_code HAVING COUNT( * ) > 1 );
```



#### 1.2.2.方案二

```sql
SELECT
	*
FROM
	student s 
WHERE
	s.id NOT IN ( SELECT temp_table.id FROM ( SELECT MIN( id ) AS id FROM student t1 GROUP BY t1.student_code ) temp_table );
```



#### 1.2.3.方案三

```sql
SELECT
	*
FROM
	student s 
WHERE s.id <> ( SELECT MIN(t1.id) FROM student t1 WHERE s.student_code = t1.student_code);
```



### 1.3.删除重复数据

> 排除 ` id` 最小的一条



#### 1.3.1.方案一

```sql
DELETE 
FROM
	student 
WHERE
	id IN (
SELECT
	temp_table.id 
FROM
	(
SELECT
	s.id AS id 
FROM
	student s 
WHERE
	s.student_code IN ( SELECT student_code FROM `student` t1 GROUP BY t1.student_code HAVING COUNT( * ) > 1 ) 
	AND s.id NOT IN ( SELECT MIN( id ) FROM `student` t2 GROUP BY t2.student_code HAVING COUNT( * ) > 1 ) 
	) temp_table 
	);
```



#### 1.3.2.方案二

```sql
DELETE 
FROM
	student 
WHERE
	id IN (
SELECT
	temp_table.id 
FROM
	(
SELECT
	s.id AS id 
FROM
	student s 
WHERE
	s.id NOT IN ( SELECT temp_table.id FROM ( SELECT MIN( t1.id ) AS id FROM student t1 GROUP BY t1.student_code ) temp_table ) 
	) temp_table 
	);
```



#### 1.3.3.方案三

```sql
DELETE 
FROM
	student 
WHERE
	id IN (
SELECT
	temp_table.id 
FROM
	(
SELECT
	s.id AS id 
FROM
	student s 
WHERE
	s.id <> ( SELECT MIN( t1.id ) FROM student t1 WHERE s.student_code = t1.student_code ) 
	) temp_table 
	);
```



## 2.概念

```json
# 局部性原理
# -- 时间局部性
# ---- 之前被访问过的数据,有可能很快会被再次访问
# -- 空间局部性
# ---- 数据和程序都有聚集成群的倾向,具备某些特征的数据可以放在一起
# 磁盘预读
# -- 内存池跟磁盘进行交互的时候,有一个最基本的逻辑单位称为:页,也叫datapage,大小一般是4k或者8k,我们进行数据读取的死后,一般读的是页的整数倍.

# -------------------

# 1.索引数据和和实际数据都存储在磁盘
# 2.当进行查询的时候,需要将磁盘的数据读取到内存中
# 3.分块进行数据读取(读取页的整数倍)
# 4.使用什么样的数据结构存储(k-v)
# -- hash
# -- tree(二叉树、BST、AVL、RBT、B-tree、B+tree)
# ------------
# B+tree 优势
# 1.性质
# 1.1.非叶子节点只存储键值信息
# 1.2.所有叶子节点之间都有一个链指针
# 1.3.数据记录都存放在叶子节点中
# 2.优势
# 2.1.非叶子节点只存储键值信息
# -- 找到一行记录最多只需要3次磁盘IO操作
# 2.2.所有的叶子结点之间都有双向指针
# -- 提高了MySQL顺序查找的能力
# 2.3.数据全部存储在叶节点中
# -- 可直接获取到数据,减少了I/O次数,提高了效率
# ------------
# B-树和B+树的区别
# 1.B+树内节点不存储数据，所有 data 存储在叶节点,查询时间复杂度固定为:O(log n).
# B-树查询时间复杂度不固定，与 key 在树中的位置有关,最好为O(1);
# 2.B+树叶节点两两相连可大大增加区间访问性，可使用范围查询等，
# B-树每个节点 key 和 data 在一起，则无法区间查找;
# 3.B+树更适合外部存储.
# 由于内节点无 data 域，每个节点能索引的范围更大更精确

# -------------------

# 索引的分类
# 主键索引 -- 主键字段
# -- 是一种特殊的唯一索引,一张表是能定义一个主键索引,主键索引用于表示一条记录,使用关键字: primary key 来创建.
# -- 不允许空值
# 唯一索引 -- 唯一字段
# -- 可以保证数据记录的唯一性
# -- 允许空值
# 普通索引 -- 非主键-非唯一
# -- 允许被缩影的数据列包含重复数据
# 全文索引 -- 全文检索
# -- 通过建立倒排索引,可以极大的提升检索效率,解决判断字段是否包含的问题.
# 组合索引 -- 多个字段值-可以共同构成索引

# 索引不是越多越好
# 1.索引的维护会非常麻烦
# 2.占用的磁盘空间变大,会导致I/O增多

# -------------------

# 聚簇索引
# -- 数据跟索引绑定存储叫做: 聚簇索引
# 非聚簇索引
# -- 数据跟索引分开存储叫做: 非聚簇索引

# -------------------

# 1.一个表中只能有一个索引吗?
# -- 可以按照需求来创建多个索引，但不要太多
# 2.每一个索引是一棵B+树还是所有的索引共用一棵B+树?
# -- 一个索引，一棵B+树
# 3.如果有多棵B+树，那么数据存储几份?
# -- 1 份
# 4.其他索引的叶子节点存放什么呢?
# -- 跟数据绑定存储的索引列的值

# -------------------

# 在 InnoDB 存储引擎中，数据在进行插入的时候需要跟某一个索引列绑定在一起,这个索引列
# 1.如果是主键,那么使用主键
# 2.如果没有主键,那么使用唯一键
# 3.如果没有唯一键,那么使用6字节的rowid

# InnoDB 既有聚簇索引也有非聚簇索引
# MyISAM 非聚簇索引

# -------------------

# 回表
# -- 查询时,先到条件对应索引的B+树中追踪到对应叶子节点的Id值,然后再根据Id到Id的B+树读取整行的记录,这种查询方式叫做: 回表,不推荐使用,效率降低.

# 索引覆盖
# -- 根据时,根据查询的条件到对应的B+树中获取对应的叶子节点中的数据,叶子节点中包含了全部查询的字段,此时叫做: 索引覆盖,推荐使用,效率高.

# 最左匹配
# 针对组合索引

# -------------------

# 主从复制
# 读写分离
# 分库分表

# -------------------

# 事务
# A - 原子性 - undolog
# C - 一致性
# I - 隔离性(MVCC)
# -- 读未提交
# -- 读已提交(RC)
# -- 可重复读(RR)
# -- 串行化
# D - 持久性 - redolog - WAL - write ahead log(预写日志)

# -------------------

# ------------------- MVCC 
# 多版本并发控制--解决数据并发读写问题
# -- 维持一个数据的多个版本,使得读写操作没有冲突，快照读是 MySQL 为了实现MVCC的一个非阻塞读功能

# 快照读 - 读取的是 MySQL 对应数据得历史版本 
# -- select
# 当前读 - 读取的是 最新 数据结果
# -- select lock in share mode
# -- select for update
# -- insert
# -- delete
# -- update

# MVCC 实现原理
# -------------------
# 1.隐藏字段 
# -- DB_TRX_ID   - 最近修改事务ID，记录创建当前记录或者最后一个修改的事务ID
# -- DB_ROLL_PTR - 回滚指针,指向这条数据的上一个版本
# -- DB_ROW_ID   - 隐藏主键
# ----------
# undolog 会形成一个链表,链首存储的是最新的旧记录,链尾存储的是最旧的旧纪录
# undolog 不会 无限制膨胀下去,会存在一个后台线程,purge 线程,当发现当前记录不需要回滚且不需要参与MVCC的时候,就会把数据清理掉.
# ----------
# 2.ReadView(读视图)
# 当事务再进行快照读的时候,会生成一个读视图来进行可见性判断
# 可见性判断是由可见性算法来确定的
# ----------
# 能否看到修改的数据,取决于可见性算法,可见性算法比较的时候取决于 readview 的结果值
# 因为,在不同的隔离级别的时候,生成 readview 的时机是不同的:
# RC: 每次执行快照读都会生成新的 readview
# RR: 只有在当前事务第一次进行快照读的时候生成 readview ,之后的快照读操作会都用当前的 readview
# ----------
# readview 比较规则
# 1.比较: DB_TRX_ID < up_limit_id
# -- 如果 <  则当前事务能看到 DB_TRX_ID 所在的记录
# -- 如果 >= 进入下一个判断
# 2.比较: DB_TRX_ID >=  low_limit_id
# -- 如果 >= 代表 DB_TRX_ID 所在的记录在 readview 生成后才出现,那么对当前事务不可见
# -- 如果 < 进入下一个判断
# 3.比较: DB_TRX_ID 是否在事务活跃列表中
# -- 如果在: 则代表在 readview 生成时,这个事务还是活跃的状态,还没有 commit 修改的数据，当前事务也是看不到的
# -- 如果不在: 则代表 这个事务在 readview 生成之前就已经开始 commit,那么修改的结果是能够看见的.
# ----------
# 2.1.trx_list       - 当前系统活跃的事务ID
# 2.2.up_limit_id    - 活跃事务列表中最小的事务ID
# 2.3.low_limit_id   - 当前系统尚未分配的下一个事务的ID
# -------------------
# 如果当前所有的操作都是当前读，那么是不会产生幻读问题;
# 只有当前读和快照都一起使用的时候才会产生幻读.
# -------------------

# 数据更新流程
# 1.执行器先从引擎中找到数据,如果数据再内存中直接返回,如果不存在内存中,查询后返回
# 2.执行器拿到数据之后会先修改数据,然后调用引擎接口重新写入数据
# 3.引擎将数据更新到内存,同时写数据到redo中,此是处于prepare阶段,并通知执行器执行完成,随时可以操作
# 4.执行器生成这个操作的binlog
# 5.执行器调用引擎的事务提交接口,引擎把刚写完的redo改成commit状态,更新完成
```



## 3.锁的类型

- 属性分类

  - 共享锁(`Share Lock`)

    - ```json
      # 共享锁又称读锁,简称`S`锁.
      # 当一个事务为数据加上读锁之后,其他事务只能对该数据加读锁,而不能对该数据加写锁,直到所有的读锁释放之后其他的事务才能对其进行加持写锁.
      # 共享锁的特性主要是为了支持并发的读取数据,读取数据的时候,不支持修改,避免出现重复读的问题.
      ```

  - 排他锁(`Exclusive Lock`)

    - ```json
      # 排他锁又称写锁,简称`X`锁.
      # 当一个事务为数据加上写锁之后,其他事务将不能再为数据加任何锁,直到该所释放之后,其他的事务才能对数据进行加锁.
      # 排他锁的目录是在数据修改的时候,不允许其他人同时修改,也不允许其他人读取,避免出现脏数据和脏读的问题.
      ```

  - 

- 粒度分类

  - 行级锁(`InnoDB`)

    - ```json
      # 行锁是指上锁的时候锁住的是表的某一行或多行记录,其他事务访问同一张表时,只有被锁住的记录不能访问,其他的记录可正常访问
      # 特点:
      # 1.粒度小,加锁比表锁麻烦,不容易冲突,相比表锁支持的并发要高
      ```

    - 

  - 表级锁(`InnoDB` `MyISAM`)

    - ```json
      # 表锁是指上锁的时候锁住的是整个表,当下一个事务访问该表的时候,必须等前一个事务释放了锁才能进行对表的访问
      # 特点:
      # 1.粒度大,加锁简单,容易冲突
      ```

    - 

  - 页级锁(`InnoDB`)

    - ```json
      # 页锁是MySQL种锁定粒度驾驭行锁和表锁之间的一种锁.
      # 表锁速度快,冲突多;
      # 行级锁冲突少,速度慢.
      # 所以取了折中的页锁,一次锁定相邻的一组记录.
      # 特点:
      # 1.开销和加锁时间介于表锁和行锁之间,会出现死锁;
      # 2.锁定粒度介于表锁和行锁之间,并发度一般.
      ```

    - 

  - 记录锁(`Record Lock`)

    - ```json
      # 记录锁也属于行锁当中的一种,只不过记录锁的范围只是表中的某一条记录,记录锁是说事务在加锁后锁住的知识表的某一条记录,加了记录锁之后数据可以避免数据在查询的时候被修改的重复读问题,也避免了在修改的事务未提交前,被其他事务读取的脏读问题
      ```

    - 

  - 间隙锁

    - ```json
      # 是属于行锁的一种,间隙锁锁在事务加锁后其锁住的是表记录的某一个区间,当表的相邻ID之间出现空隙则会形成一个区间,遵循左开右闭原则.
      # 范围查询并且查询未命中记录,查询条件必须命中索引,间隙锁只会出现在 RR 的事务级别中
      ```

    - 

  - 临键锁(`Next-Key Lock`)

    - ```json
      # 也属于行锁的一种,并且他是InnoDB的行锁默认算法.
      # 总结来说,就是记录或和间隙锁的组合,临键锁会把查询出来的记录锁住,同时也会把该范围查询内的所有间隙空间也锁住,再之它会把相邻的下一个区间也锁住.
      ```

    - 

- 状态分类

  - 意向共享锁
  - 意向排他锁